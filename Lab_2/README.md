# Отчет о выполнении лабораторной работы №2. Вариант 5
# Отладка кода

## Задание 1
Разработайте программу на языке C++, вычисляющую три целых
выражения от целого аргумента (в соответствии с вариантом).

### Вариант: 
- а) y(x)=x*5;
- б) y(x)=x*7;
- в) y(x)=(0,если x<7;x, x>=7) - система.

### Решение:

#### [си код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/1.cpp)
#### [ассемблерый код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/1.cpp)

## Задание 2
Запустите программу и, используя инструменты отладчика (в част
ности, дизассемблер), изучите ассемблерный код, соответствующий вычислениям
(для Code::Blocks—переключитесь на синтаксис AT&T и включите Mixed mode,
чтобы в окне дизассемблера перед каждой группой команд, соответствующих
одному оператору языка высокого уровня, явно отображался этот оператор).
Занесите ассемблерный код, соответствующий вычислению y(x), в отчёт (код,
не связанный с вычислением y(x), копировать в отчёт не нужно!). Определите и
прокомментируйте:
– обращение к переменным x и y;
– арифметические и логические операции—сложение, вычитание, умножение,
деление с остатком, деление на 2<sup>n</sup> и т. д. (по возможности);
– сравнения и передачу управления в ветвлениях.

### Решение:

#### 1)	#define
``` 
  #define bar() \
	int var = 10;\
	printf("result=: %d\n", var*7)
```

```
;27 :		bar();
0x40155d	movl   $0xa,-0x1c(%ebp)
0x401564	mov    -0x1c(%ebp),%edx
0x401567	mov    %edx,%eax
0x401569	shl    $0x3,%eax
0x40156c	sub    %edx,%eax
0x40156e	mov    %eax,0x4(%esp)
0x401572	movl   $0x405079,(%esp)
0x401579	call   0x403c08 <printf>
```
##### Вывод: 
Препроцессор заменил «bar();» на код, который описан в define.  Ассемблерный код принципиально ничем не отличается от кода внутри main(). 

#### 2)	Глобальные переменные:

#### Участки отличающегося кода с глобальными переменными:
```
;12 :	int main() {
0x401460	lea    0x4(%esp),%ecx
0x401464	and    $0xfffffff0,%esp
0x401467	pushl  -0x4(%ecx)
0x40146a	push   %ebp
0x40146b	mov    %esp,%ebp
0x40146d	push   %edi
0x40146e	push   %esi
0x40146f	push   %ebx
0x401470	push   %ecx
0x401471	sub    $0x28,%esp
0x401474	call   0x401b30 <__main>
```

```
;15 :		y1 = x * 5;
0x401479	mov    0x404004,%edx
0x40147f	mov    %edx,%eax
0x401481	shl    $0x2,%eax
0x401484	add    %edx,%eax
0x401486	mov    %eax,0x407020
```

#### Участки отличающегося кода без глобальных переменных:
```
;8  :	int main() {
0x401460	lea    0x4(%esp),%ecx
0x401464	and    $0xfffffff0,%esp
0x401467	pushl  -0x4(%ecx)
0x40146a	push   %ebp
0x40146b	mov    %esp,%ebp
0x40146d	push   %ecx
0x40146e	sub    $0x24,%esp
0x401471	call   0x401b30 <__main>
```

```
;15 :		y1 = x * 5;
0x401492	mov    -0x10(%ebp),%edx
0x401495	mov    %edx,%eax
0x401497	shl    $0x2,%eax
0x40149a	add    %edx,%eax
0x40149c	mov    %eax,-0x14(%ebp)
```

##### Вывод:
В блоке main() добавились push в edi ,esi и ebx.
Далее при непосредственном вычислении значений функций Y – используются конкретные адреса(?)(0x404004), а не место в регистре(-0x10(%ebp)).

#### 3)	Char
##### [Код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/3char.s)

#### 4)	Short
##### [Код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/3short.s)
##### Вывод:
Работа с типом short имеет изменения в операциях, некоторые из них имеют суффикс “w”(movw), который свидетельствует  о том, что операция производится с операндами длиной в 2 байта.

#### 5)	Long
##### 
