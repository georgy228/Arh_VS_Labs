# Отчет о выполнении лабораторной работы №2. Вариант 5
# Отладка кода

## Задание 1
Разработайте программу на языке C++, вычисляющую три целых
выражения от целого аргумента (в соответствии с вариантом).

### Вариант: 
- а) y(x)=x*5;
- б) y(x)=x*7;
- в) y(x)=(0,если x<7;x, x>=7) - система.

### Решение:

#### [си код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/1.cpp)
#### [ассемблерый код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/1.cpp)



## Задание 2
Запустите программу и, используя инструменты отладчика (в част
ности, дизассемблер), изучите ассемблерный код, соответствующий вычислениям
(для Code::Blocks—переключитесь на синтаксис AT&T и включите Mixed mode,
чтобы в окне дизассемблера перед каждой группой команд, соответствующих
одному оператору языка высокого уровня, явно отображался этот оператор).
Занесите ассемблерный код, соответствующий вычислению y(x), в отчёт (код,
не связанный с вычислением y(x), копировать в отчёт не нужно!). Определите и
прокомментируйте:
– обращение к переменным x и y;
– арифметические и логические операции—сложение, вычитание, умножение,
деление с остатком, деление на 2<sup>n</sup> и т. д. (по возможности);
– сравнения и передачу управления в ветвлениях.
### Решение:
#### [Си код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/2.cpp)
#### [Ассемблерный код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/2.s)

## Задание 3
Внесите в программу из задания 1, а) изменения (либо, что предпо
чтительнее, добавьте новые фрагменты кода, выполняющие аналогичные вычис
ления для других переменных, используя макросы препроцессора или шаблоны
C++).
– сделайте переменные глобальными;
– измените тип с int на char, short, long и long long;
– измените тип с int на long double.
Опишите в отчёте различия в ассемблерном коде.

### Решение:

#### 1)	#define
``` 
  #define bar() \
	int var = 10;\
	printf("result=: %d\n", var*7)
```

```
;27 :		bar();
0x40155d	movl   $0xa,-0x1c(%ebp)
0x401564	mov    -0x1c(%ebp),%edx
0x401567	mov    %edx,%eax
0x401569	shl    $0x3,%eax
0x40156c	sub    %edx,%eax
0x40156e	mov    %eax,0x4(%esp)
0x401572	movl   $0x405079,(%esp)
0x401579	call   0x403c08 <printf>
```
##### Вывод: 
Препроцессор заменил «bar();» на код, который описан в define.  Ассемблерный код принципиально ничем не отличается от кода внутри main(). 

#### 2)	Глобальные переменные:

#### Участки отличающегося кода с глобальными переменными:
```
;12 :	int main() {
0x401460	lea    0x4(%esp),%ecx
0x401464	and    $0xfffffff0,%esp
0x401467	pushl  -0x4(%ecx)
0x40146a	push   %ebp
0x40146b	mov    %esp,%ebp
0x40146d	push   %edi
0x40146e	push   %esi
0x40146f	push   %ebx
0x401470	push   %ecx
0x401471	sub    $0x28,%esp
0x401474	call   0x401b30 <__main>
```

```
;15 :		y1 = x * 5;
0x401479	mov    0x404004,%edx
0x40147f	mov    %edx,%eax
0x401481	shl    $0x2,%eax
0x401484	add    %edx,%eax
0x401486	mov    %eax,0x407020
```

#### Участки отличающегося кода без глобальных переменных:
```
;8  :	int main() {
0x401460	lea    0x4(%esp),%ecx
0x401464	and    $0xfffffff0,%esp
0x401467	pushl  -0x4(%ecx)
0x40146a	push   %ebp
0x40146b	mov    %esp,%ebp
0x40146d	push   %ecx
0x40146e	sub    $0x24,%esp
0x401471	call   0x401b30 <__main>
```

```
;15 :		y1 = x * 5;
0x401492	mov    -0x10(%ebp),%edx
0x401495	mov    %edx,%eax
0x401497	shl    $0x2,%eax
0x40149a	add    %edx,%eax
0x40149c	mov    %eax,-0x14(%ebp)
```

##### Вывод:
В блоке main() добавились push в edi ,esi и ebx.
Далее при непосредственном вычислении значений функций Y – используются конкретные адреса(?)(0x404004), а не место в регистре(-0x10(%ebp)).

#### 3)	Char
##### [Код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/3char.s)
##### [Код си](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/3char.cpp)

#### 4)	Short
##### [Код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/3short.s)
##### Вывод:
Работа с типом short имеет изменения в операциях, некоторые из них имеют суффикс “w”(movw), который свидетельствует  о том, что операция производится с операндами длиной в 2 байта.

#### 5)	Long
##### [Код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/3long.s)
##### Вывод: 
Работа с типом long имеет изменения в операциях, некоторые из них имеют суффикс “l”(movl), который свидетельствует  о том, что операция производится с операндами длиной в 4 байта.

#### 6)	Long long
##### [Код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/3longlong.s)
##### Вывод:
Работа с типом long long имеет изменения в операциях, некоторые из них имеют суффикс “l”(movl), который свидетельствует  о том, что операция производится с операндами длиной в 4 байта. Также, ввиду того, что данный тип имеет размер 8 байт, работа с переменными данного типа получается как работа с двумя переменными по 4 байта. 
```
7  :		long long y1=0;
0x40147e	movl   $0x0,0x20(%esp)
0x401486	movl   $0x0,0x24(%esp)
```
При работе с типом long, было бы достаточно только одной такой строчки, т.к. long – 4 байта.
Таким образом, все операции с одной переменной long long, выглядят, как работа с двумя переменными long.

#### 7)	Long double
##### [Код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/3longdouble.s)
##### Вывод:
В программе с типом long double используются комманды для работы с вещественными значениями(fldt, fmulp, fstpt). 
Принцип работы похож на работу с вещественными переменными, разве что размер переменных – 6 байт.

## Задание 4
Оформите вычисления из задания 1, а) как целую функцию от це
лого аргумента. Опишите в отчёте код вызова функции. Как передаётся аргумент?
Как возвращается значение?
##### [Код main](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/4main.s)
##### [Код функции](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/4func.s)

## Задание 5
Измените тип аргумента и результата на вещественный. Опиши
те в отчёте код вызова функции. Как передаётся аргумент? Как возвращается
значение?
### [Си код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/5.cpp)
### [Ассемблерный код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/5.s)

## Задание 6
Используйте в функции статическую перемен
ную. Как выглядит обращение к ней?
### [Си код](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/6.cpp)
### [Ассемлерный код main](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/6main.s)
### [Ассемлерный код функции](https://github.com/sekibura/Arh_VS_Labs/blob/master/Lab_2/code/6func.s)
#### Вывод:
Отличия в коде наблюдаются только на уровне кода самой функции, при работе с у1 происходит обращение не к регистру, а к адресу памяти.
